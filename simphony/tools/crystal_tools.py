from simphony.cuds.particles import Particle, Particles
from simphony.core.cuba import CUBA

import numpy as np


def create_particles_from_points (latt_vectors, latt_points):
    ''' create a Particles Dataset from a collection of points, lattice parameter, and unit cell

    Parameter
    ---------
    file_name : name of file to write, including path.
    Returns
    -------
    currently: none
    ''' 


def write_particles_to_exyz_file(particles, file_name):
    ''' write an EXZY file for AViz visualisation tool
    Parameter
    ---------
    particles : a SimPhoNy Particles DataSet
    file_name : name of file to write, including path.
    Returns
    -------
    currently: none
    ''' 

    f = open(file_name+".exyz", "w")
    f.write("{}\n".format(particles.count_of(CUDSItem.PARTICLE)))
    f.write("File generated by SimPhoNy 0.0.1\n")
    # normally the types of atoms should be inferred either from the 
    # DataContainer of each atom or form the Material 
    # For now we assume one type, randomly chosen as Al.
    for p in particles.iter_particles():
        f.write("Al {:f} {:f} {:f} ".format(
            p.coordinates[0],
            p.coordinates[1],
            p.coordinates[2]))
        # need to check first if the velocity exists.
        f.write(" {:f} {:f} {:f}\n".format(
            p.data[CUBA.VELOCITY][0],
            p.data[CUBA.VELOCITY][1],
            p.data[CUBA.VELOCITY][2]))
    # assume the supercell is already multiplied by the
    # lattice parameter This should be an issue for the
    # conversion work.
    f.write("alat\n"+"{:+f}\n".format(1.0))
    super_cell = particles.data_extension[
        lammps.CUBAExtension.BOX_VECTORS]
    f.write("supercell\n {:+f} {:+f} {:+f}\n".format(
        super_cell[0][0],
        super_cell[0][1],
        super_cell[0][2]))

    f.write(" {:+f} {:+f} {:+f}\n".format(
        super_cell[1][0],
        super_cell[1][1],
        super_cell[1][2]))

    f.write(" {:+f} {:+f} {:+f}\n".format(
        super_cell[2][0],
        super_cell[2][1],
        super_cell[2][2]))
    f.write(" Mass Al 1.0 \n")
    f.write("Cartesian coordinates\n")
    f.close()


def cart_to_latt_coords (latt_vecs, latt):
    ''' convert the lattice positions in latt from real (cartesian) to lattice coordinates
    Parameter
    ---------
    latt_vecs: current lattice vectors, each vector as a row.  
    latt     : artay-like, the points of the crystal lattice in lattice coordinates
    Return:
    ---------
    latt_r     : the coverted lattice positions
    '''
    # todo: check if lattice coords are indeed in cartesian 
    latt_vecs = np.matrix (latt_vecs) 
    latt_vecs_inv = latt_vecs.T.I

    latt_r = np.zeros((len(latt), 3))
    for i in xrange(len(latt)):
        latt_r[i] = np.dot(latt_vecs_inv, latt[i])

    return (latt_r) 
    

def latt_to_cart_coords (latt_vecs, latt):
    ''' convert the lattice positions in latt from lattice to real (cartesian) coordinates
    Parameter
    ---------
    latt_vecs: current lattice vectors 
    latt     : artay-like, the points of the crystal lattice in lattice coordinated
    Return:
    ---------
    latt_r     : the coverted lattice positions
    '''
    latt_vecs = np.matrix (latt_vecs) 
    latt_vecs_T = latt_vecs.T

    latt_cart = np.zeros((len(latt), 3))
    #latt_r = latt
    for i in xrange(len(latt)):
        latt_cart [i] = np.dot(latt_vecs_T, latt[i])

    return (latt_cart) 


def duplicate_lattice(current_lattice_vectors, current_lattice, dup_factors, reduced_coors):
    ''' Duplicate a lattice along the lattice vectors 
    Parameter
    ---------
    current_lattice_vectors : array-like, super-cell 
            
            can be primitive vectors in case of a primitive unit cell or 
	    conventional vectors in case of a conventional unit cell or 
	    a general lattice vectors of a general lattice.


    current_lattice  : array-like, 
            
             the lattice points, used here as the basis for duplication

    dup_factors: vector-like, 
             
             the duplication factors, 
             how many times to repeat the current_lattice 
             in the direction of each unit cell/conventional cell/super-cell 
			 directions 
            
    reduced_coors: Bolean, 
        
             whether the coordinates are reduced (lattice vector units), or real (cartesian)
	    
   Returns
   -------
	    new_lattice : the duplicated lattice
	    new_lattice_vectors : the new lattice vectors with duplicatoin 
    ''' 

    vaxis = 0 
    for vaxis in xrange (3):
	size0 = len(current_lattice)
	new_lattice_size = dup_factors[vaxis] * size0
	new_lattice = np.zeros((new_lattice_size, 3))

	for i in xrange(size0):
	    new_lattice[i] = current_lattice[i]

	i = 0
	for idup in xrange(dup_factors[vaxis]):
	    for j in xrange(size0):
		# to do: add copy type
		for k in xrange(3):
		    new_lattice[i][k] = new_lattice[j][k] + idup * current_lattice_vectors [vaxis][k]
		# Copy properties
		i += 1
	new_lattice_vectors = current_lattice_vectors
	for k in xrange(3):
	    new_lattice_vectors[vaxis][k] *= dup_factors[vaxis]
	
	current_lattice = new_lattice 
	current_lattice_vectors = new_lattice_vectors
        
    
    if (reduced_coors == True): 
        for i in xrange(new_lattice_size):
            for k in xrange(3):
                new_lattice[i][k] /= dup_factors[k]

    return new_lattice, new_lattice_vectors


def test_duplicate_lattice(reduced_coors):
#    global new_lattice_vectors, new_lattice
    # Use a SC unit cell with basis for the FCC system
    current_lattice_vectors = [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]

    # The number of periodic images, or duplications of the unit cell in each
    # cubic lattice direction
    N_dup = [4, 4, 4]
    # The basis of the FCC system in the SC setup:
    current_lattice = np.matrix([
        [0.0, 0.0, 0.0],
        [0.5, 0.5, 0.0],
        [0.5, 0.0, 0.5],
        [0.0, 0.5, 0.5]
    ])
    if reduced_coors==True:
        new_lattice, new_lattice_vectors = duplicate_lattice(current_lattice_vectors, current_lattice, N_dup, True)
    else:
        current_lattice = latt_to_cart_coords ( current_lattice_vectors, current_lattice)
        new_lattice, new_lattice_vectors = duplicate_lattice(current_lattice_vectors, current_lattice, N_dup, False)

    return new_lattice, new_lattice_vectors 

def test_latt_to_cart ():
    latt, latt_vecs = test_duplicate()
    latt_r = latt_to_cart_coords(latt_vecs, 3.615, latt)
    return latt, latt_vecs

def test_cart_to_latt ():
    latt, latt_vecs = test_duplicate()
    latt_r = cart_to_latt_coords(latt_vecs, 3.615, latt)
    return latt, latt_vecs



if __name__ == '__main__':
    main()

