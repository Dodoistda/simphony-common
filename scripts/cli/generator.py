from __future__ import print_function

import os
import re
import shutil
import warnings

import yaml
import click

from ..generate import (
    CodeGenerator,
    IMPORT_PATHS, CUBA_DATA_CONTAINER_EXCLUDE)
from scripts.utils import make_temporary_directory, to_camel_case


@click.group()
def cli():
    """ Auto-generate code from simphony-metadata yaml description. """

@cli.command()
@click.argument('yaml_file', type=click.File('rb'))
@click.argument('out_path', type=click.Path())
@click.option('-O', '--overwrite', is_flag=True, default=False,
              help='Overwrite OUT_PATH')
def meta_class(yaml_file, out_path, overwrite):
    """ Create the Simphony Metadata classes

    YAML_FILE  - path to the simphony_metadata yaml file

    OUT_PATH   - path to the directory where the output files should be placed
    """

    if os.path.exists(out_path):
        if overwrite:
            shutil.rmtree(out_path)
        else:
            raise OSError('Destination already exists: {!r}'.format(out_path))

    yml_data = yaml.safe_load(yaml_file)

    all_generators = {}

    # Temporary directory that stores the output
    with make_temporary_directory() as temp_dir:

        for key, class_data in yml_data['CUDS_KEYS'].items():
            # Catch inconsistent definitions that would choke the generator
            parent = class_data['parent']
            if (parent and
                    parent.replace('CUBA.', '') not in yml_data['CUDS_KEYS']):
                message = ('{0} is SKIPPED because its parent {1} '
                           'is not defined in CUDS_KEYS')
                warnings.warn(message.format(key, class_data['parent']))
                continue

            if key.lower() in ('validation', 'api'):
                message = 'Name crashes with utility modules: '+key.lower()
                raise ValueError(message)

            # Create the generator object, on init, it identifies its own
            # required/optional user-defined attributes and
            # system-managed attributes
            all_generators[key] = CodeGenerator(key, class_data)

        for key, gen in all_generators.items():
            # Collect parents and attributes inherited from parents
            gen.collect_parents_to_mro(all_generators)
            gen.collect_attributes_from_parents(all_generators)

            # Target .py file
            filename = os.path.join(temp_dir,
                                    "{}.py".format(gen.original_key.lower()))

            # Now write the code
            with open(filename, 'wb') as generated_file:
                gen.generate(file_out=generated_file)

            # Print to the api.py
            with open(os.path.join(temp_dir, "api.py"), 'ab') as api_file:
                print('from .{} import {}   # noqa'.format(key.lower(),
                                                           to_camel_case(key)),
                      sep='\n', file=api_file)

        # Create an empty __init__.py
        init_path = os.path.join(temp_dir, '__init__.py')
        open(init_path, 'a').close()

        # Create validation.py
        validation_path = os.path.join(temp_dir, 'validation.py')

        from .. import validation
        # validation.py for validation codes.
        validation_py_path = os.path.splitext(validation.__file__)[0]+'.py'

        with open(validation_path, 'wb') as dst_file, \
                open(validation_py_path, 'rb') as src_file:

            # Replace import path for KEYWORDS
            def read_lines(src_file):
                while True:
                    line = src_file.next()
                    yield re.sub(r'(\s*).+import KEYWORDS',
                                 "\\1"+IMPORT_PATHS['KEYWORDS'], line)

            # Copy the rest of the file
            print(*read_lines(src_file), file=dst_file, sep='')

        # Copy everything to the output directory
        shutil.copytree(temp_dir, out_path)


@cli.command()
@click.argument('cuba_input', type=click.File('rb'))
@click.argument('cuds_input', type=click.File('rb'))
@click.argument('output', type=click.File('wb'))
def cuba_enum(cuba_input, cuds_input, output):
    """ Create the CUBA Enum

    CUBA_INPUT  - Path to the cuba.yml

    CUDS_INPUT  - Path to the simphony_metadata.yml

    OUTPUT      - Path to the output cuba.py file
    """
    keywords = yaml.safe_load(cuba_input)
    metadata = yaml.safe_load(cuds_input)

    lines = [
        '# code auto-generated by the\n',
        '# simphony-metadata/scripts/generate.py script.\n',
        '# cuba.yml VERSION: {}\n'.format(keywords['VERSION']),
        'from enum import Enum, unique\n',
        '\n',
        '\n',
        '@unique\n',
        'class CUBA(Enum):\n',
        '\n']
    template = '    {} = "{}"\n'

    all_keys = set(keywords['CUBA_KEYS']) | set(metadata['CUDS_KEYS'])

    for keyword in sorted(list(all_keys)):
        if keyword in CUBA_DATA_CONTAINER_EXCLUDE:
            continue
        lines.append(template.format(keyword, keyword))

    output.writelines(lines)


@cli.command()
@click.argument('cuba_input', type=click.File('rb'))
@click.argument('cuds_input', type=click.File('rb'))
@click.argument('output', type=click.File('wb'))
def keywords(cuba_input, cuds_input, output):
    """ Create a dictionary of CUDS keywords.

    CUBA_INPUT  - Path to the cuba.yml

    CUDS_INPUT  - Path to the simphony_metadata.yml

    OUTPUT      - Path to the output cuba.py file
    """
    keywords = yaml.safe_load(cuba_input)
    metadata = yaml.safe_load(cuds_input)

    lines = [
        '# code auto-generated by the\n',
        '# simphony-metadata/scripts/generate.py script.\n',
        '# cuba.yml VERSION: {}\n'.format(keywords['VERSION']),
        '# simphony_metadata.yml VERSION: {}\n'.format(metadata['VERSION']),
        'from collections import namedtuple\n',
        '\n',
        'import numpy\n',
        'import uuid  # noqa\n',
        '\n',
        '\n',
        'ATTRIBUTES = [\n'
        '    "name", "definition", "key", "shape", "dtype"]\n'  # noqa
        'Keyword = namedtuple("Keyword", ATTRIBUTES)\n',
        '\n',
        '\n',
        'KEYWORDS = {\n']
    data_types = {
        'uuid': 'uuid.UUID',
        'string': 'numpy.str',
        'double': 'numpy.float64',
        'integer': 'numpy.int32',
        'boolean': 'bool'}
    template = (
        "    '{key}': Keyword(\n"
        "        name='{name}',\n"
        "        definition='{definition}',  # noqa\n"
        "        key='{key}',\n"
        "        shape={shape},\n"
        "        dtype={type}),\n")
    for keyword, content in sorted(keywords['CUBA_KEYS'].items(),
                                   key=lambda x: x[0]):
        content['type'] = data_types[content['type']]
        content['name'] = to_camel_case(keyword)
        content['key'] = keyword
        lines.extend(template.format(**content))

    for keyword, content in sorted(metadata['CUDS_KEYS'].items(),
                                   key=lambda x: x[0]):
        content['type'] = "None"
        content['name'] = to_camel_case(keyword)
        content['key'] = keyword
        content['shape'] = [1]
        lines.extend(template.format(**content))
    lines.append('}\n')

    output.writelines(lines)

